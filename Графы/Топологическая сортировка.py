def topological_sort(g: {}, n: int):
    """
    :param g: Ориентированный ацикличный граф с вершинами, пронумерованными от 1 до n.
    граф представлен в виде списка смежности
    :param n: Количество вершин в графе
    :return: Линейное упорядочивание вершин, такое, что вершина u находится в нем до вершины v,
    если (u, v) - ребро графа
    """
    # Рассчитываем для каждой вершины количество путей в нее из других вершин
    in_degree = [0] * (n+1)  # линейное упорядочивание вершин
    for u, value in g.items():
        for v in value:
            in_degree[v] += 1

    # Находим вершины в которые не ведут другие
    next_ = [u for u in range(len(in_degree)) if in_degree[u] == 0 and u != 0]

    while len(next_) > 0:
        u = next_.pop()  # Удаляем вершину - родителя, в которую не ведут другие
        in_degree.append(u)  # добавляем ее в конец линейного упорядочивания
        # в каждой смежной вершине с родительской уменьшаем количество
        # связей, тк мы уже добавили вершину в линейное упорядочивание
        # Эта вершина является обработанной, и можно представить как будто ее уже нет в графе
        for v in g.get(u,[]):
            in_degree[v] -= 1
            # Если количество связей упало до нуля, то
            # вершина теперь родительская, и ее можно добавить следующей в словарь на обработку
            if in_degree[v] == 0:
                next_.append(v)
    return [i for i in in_degree if i != 0]


if __name__ == "__main__":
    graph = {
        1: [2,3],
        2: [3],
        3: [4,5]
    }
    print(topological_sort(graph, 5))
