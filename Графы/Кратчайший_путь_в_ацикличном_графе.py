def relax(w, u, v, shortest, pred):
    """
    :param w: Веса графа
    :param u: Вершина 1
    :param v: Вершина 2
    :param shortest: Массив минимальных расстояний до точки
    :param pred: Массив по которому можно восстановить кратчайший путь
    :return: Функция уменьшает значения для вершин, если нашелся такой путь, который короче чем был до этого
    """
    # Если путь новой вершины короче, чем тот который был сохранен ранее, тогда
    # меняем значения
    if shortest[u] + w[(u, v)] < shortest[v]:
        shortest[v] = shortest[u] + w[(u, v)]
        pred[v] = u


def dag_shortest_paths(g, w, n, s):
    """
    :param g: Граф, хранимый списком смежности
    :param w: Веса графа
    :param n: Количество вершин в графе
    :param s: Вершина от которой находятся расстояния до других
    :return: Кратчайшие пути до вершин
    """
    from Топологическая_сортировка import topological_sort
    l = topological_sort(g, n)  # Выполняем линейное упорядочивание топологической сортировкой
    # Создаем массив, состоящий из бесконечностей, чтобы обозначить недосягаемые вершины
    shortest = [float('inf')] * (n+1)
    shortest[s] = 0  # Расстояние от начальной вершины = 0 тк мы уже достигли ее
    pred = [None] * (n+1)  # Массив, в котором хранятся пути для того, чтобы обратно воссоздать маршрут
    for u in l:  # Перебираем линейно упорядоченные вершины
        for v in g.get(u, []):
            relax(w, u, v, shortest, pred)  # перестраиваем пути для каждой смежной вершины

    return shortest, pred


if __name__ == "__main__":
    graph = {
        1: [2, 3],
        2: [3],
        3: [4, 5]
    }

    weights = {
        (1, 2): 4,
        (1, 3): 6,
        (2, 3): 1,
        (3, 4): 2,
        (3, 5): 3
    }

    print(dag_shortest_paths(graph, weights, 5, 1))
