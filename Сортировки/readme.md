# Сортировки

## Оглавление
+ [Сортировка выбором](#choice_sort)
+ [Сортировка вставкой](#insert_sort)
+ [Сортировка слиянием](#merge_sort)


## Теория

### <a name="choice_sort">Сортировка выбором</a>

#### Алгоритм:
1) Организуем цикл по массиву `range(n)`
2) На каждой итерации находим индекс самого маленького элемента в срезе от [i:n]
3) Меняем элемент i с найденным местами

|Сортировка|Худший случай|Средний случай|Лучший случай|Доп память|
|:----------:|-------------|:--------------:|:-------------:|:----------:|
|Сортировка выбором| **О(n<sup>2</sup>)**| **О(n<sup>2</sup>)**|**О(n<sup>2</sup>)**|Нет|


### <a name="insert_sort">Сортировка вставкой</a>

#### Алгоритм
1) Организуем цикл по массиву `range(1,n)`
2) На каждой итерации идем в обратном порядке к началу массива и
ищем элемент который меньше чем `a[i]` и меняем значение `a[j+1]=a[j]`,
   чтобы сделать смещение элементов при вставке нового.
   
3) Когда нашелся такой элемент или мы дошли до конца массива делаем
`a[j+1] = a[i]`
   
|Сортировка|Худший случай|Средний случай|Лучший случай|Доп память|
|:----------:|-------------|:--------------:|:-------------:|:----------:|
|Сортировка вставкой| **О(n<sup>2</sup>)**| **О(n)**|**О(n<sup>2</sup>)**|Нет|


### <a name="merge_sort">Сортировка слиянием</a>

#### Алгоритм
Суть алгоритма заключается в реализации двух функций:
`merge_sort(a,p,r)` и `merge(a,p,q,r)`, где `p`- левая граница сортируемого массива
`q` - середина сортируемого отрезка, а `r`- правая граница. Все границы включительно.

Алгоритм `merge_sort`:
0) Пишем условие выхода `if p >= r: return` (Если левая граница >= правой то длина массива меньше 1)
1) Находим середину сортируемого отрезка `q` = `(p+r) // 2`
2) Вызываем функции `merge_sort(a,p,q)` и `merge_sort(a, q+1,r)`
3) Вызываем функцию `merge(a,p,q,r)`
4) Возвращаем отсортированный массив

Алгоритм `merge`:
1) Создаем два массива `b = a[p:q+1]` и `c = a[q+1:r+1]` - левая и правая часть отрезков
2) Закидываем им в конец бесконечности (нужно для удобства реализации)
`b.append(float('inf'))` и `c.append(float('inf'))`
   
3) Заводим два индекса `i` и `j`. Они будут служить указателями на
позиции в наших массивах. А далее итерируемся по массиву `a` (`range(p, r+1)`) и
   сравниваем элементы `b[i]` и `c[j]`. Если `b[i]` > `c[j]` тогда к `a[k]` присваиваем `b[i]` и увеличиваем i на единицу. 
   Аналогично для `c[j]` и `j` в иной ситуации.
   

|Сортировка|Худший случай|Средний случай|Лучший случай|Доп память|
|:----------:|-------------|:--------------:|:-------------:|:----------:|
|Сортировка слиянием| **О(nlog(n))**| **О(nlog(n))**| **О(nlog(n))**|Да|
